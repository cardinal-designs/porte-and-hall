{{ 'template-collection.css' | asset_url | stylesheet_tag }}
{{ 'component-product-card.css' | asset_url | stylesheet_tag }}
{{ 'component-price.css' | asset_url | stylesheet_tag }}
{{ 'component-product-grid.css' | asset_url | stylesheet_tag }}
{{ 'component-collection-filters.css' | asset_url | stylesheet_tag }}
{{ 'component-sticky-collection-filters.css' | asset_url | stylesheet_tag }}

<style>
  @media screen and (max-width: 768px) {

  #ProductGridContainer {
    margin: 0 0 24px;
  }

}

.sticky-filters-bar {
  --filter-bg-color: {{ section.settings.bg_color }};
  --filter-text-color: {{ section.settings.text_color }};
}

</style>

<script src="{{ 'collection-filters.js' | asset_url }}" defer="defer"></script>

{% assign active_tags = '' %}
{% for tag in current_tags %}
  {% assign tag_as_handle = tag | replace: '&#39;', '' | replace: '&#34;', '' | handle %}
  {% assign active_tags = active_tags | append: tag_as_handle %}
  {% unless forloop.last %}{% assign active_tags = active_tags | append: '+' %}{% endunless %}
{% endfor %}

<link rel="preload" href="{{ 'component-rte.css' | asset_url }}" as="style" onload="this.onload=null;this.rel='stylesheet'">

<div class="page-width">
  <div class="collection-grid__inner">

    <div id="sticky-wrap-{{ section.id }}" class="sticky-filters-wrap" data-section-id="{{ section.id }}">
      <div id="sticky-bar-{{ section.id }}" class="sticky-filters-bar" role="region" aria-label="Collection filters">
        {% if section.blocks.size > 0 %}
          <div class="head-slide-wrap title-carousel" id="head-slide-wrap">
            <ul class="head-slide">
              {%- capture contentForQuerystring -%}{{ content_for_header }}{%- endcapture -%}
                {%- assign pageUrl = contentForQuerystring
                  | split: '"pageurl":"'
                  | last
                  | split: '"'
                  | first
                  | split: '.myshopify.com'
                  | last
                  | replace: '\/', '/'
                  | replace: '%20', ' '
                  | replace: '\u0026', '&'
              -%}
              {% capture finalurl %}https://{{ pageUrl }}{% endcapture %}

              {%- assign key_and_value = pageUrl | split:'?' -%}

              {% for block in section.blocks %}
                <li {% if block.settings.link contains key_and_value[1] %} class="active" {% endif %}><a href="{{ block.settings.link }}">{{ block.settings.title }}</a></li> 
              {% endfor %}
            </ul>
          </div>
        {% endif %}
        <div class="sticky-filters-bar__inner">
          {% render 'collection-filters' %}
        </div>
      </div>
      <div id="sticky-placeholder-{{ section.id }}" class="sticky-filters-placeholder" aria-hidden="true"></div>
    </div>

    <div id="ProductGridContainer">
      {% if collection.products.size == 0 %}
        <div class="collection collection--empty" id="product-grid" data-id="{{ section.id }}">
          <div class="loading-overlay gradient"></div>
          <div class="title-wrapper center">
            <h2 class="title title--primary">
              {{ 'sections.collection_template.empty' | t -}}
              <br>
              {{ 'sections.collection_template.use_fewer_filters_html' | t }}
              <button onclick="clearAll(event)" class="h2 collection-filter-clear-all">clear all</button>.
            </h2>
          </div>
        </div>
      {% else %}
        <div class="collection">
          {% paginate collection.products by 50 %}
            <ul id="product-grid" data-id="{{ section.id }}" class="product-grid product-grid-4 list-unstyled">
              {% for product in collection.products %}
                {% for collection in product.collections %}
                  {% if collection.title contains ' |' %}
                    {% assign grouped_collection = collection %}
                  {% endif %}
                {% endfor %}
                <li class="product-grid__item">
                  {% render 'grouped-product-card-4',
                    product_card_product: product,
                    collection: grouped_collection,
                    title: grouped_collection.title,
                    button_text: 'Shop Now',
                    forloop_index: forloop.index
                  %}
                </li>
              {% endfor %}
            </ul>

            <div id="load-more-wrapper" class="load-more-wrapper">
              {% if paginate.pages > 1 and paginate.next %}
                <load-more role="button" class="button" data-load-more="{{ paginate.next.url }}">
                  <span>Load more</span>
                  <div class="loading-overlay__spinner">
                    <svg aria-hidden="true" focusable="false" role="presentation" class="spinner" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
                      <circle class="path" fill="none" stroke-width="6" cx="33" cy="33" r="30"></circle>
                    </svg>
                  </div>
                </load-more>
              {% endif %}
            </div>
          {% endpaginate %}
        </div>
      {% endif %}
    </div>

    <div class="loading-overlay">
      <div class="loading-overlay__spinner">
        <svg aria-hidden="true" focusable="false" role="presentation" class="spinner" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
          <circle class="path" fill="none" stroke-width="6" cx="33" cy="33" r="30"></circle>
        </svg>
      </div>
    </div>

  </div>
</div>
<script>
  /**
  * Sticky Element Utilities
  * Reusable functions for creating sticky navigation, filters, and headers
  */

  window.StickyUtils = (function() {
    'use strict';

    // ========================================
    // CORE UTILITIES
    // ========================================

    /**
    * Calculate the total offset from fixed header elements
    * @param {Object} options - Configuration options
    * @param {boolean} options.includeNav - Include navigation height
    * @param {number} options.extraOffset - Additional offset to add
    * @param {boolean} options.desktopOnly - Only apply to desktop viewports
    * @returns {number} Total offset height in pixels
    */
    function getHeaderOffset(options = {}) {
      const {
        includeNav = true,
        extraOffset = 0,
        desktopOnly = false
      } = options;

      const header = document.querySelector('#shopify-section-header, .header-wrapper, header[role="banner"]');
      const announcement = document.querySelector('#shopify-section-announcement-bar, .announcement-bar');
      const nav = document.querySelector('.header__navigation');
      const bxCreative = document.querySelector('.bx-creative');

      let navHeight = 0;
      if (includeNav && nav) {
        const navStyles = getComputedStyle(nav);
        const isFixed = /(fixed|sticky)/.test(navStyles.position);
        const isDesktop = window.matchMedia('(min-width: 990px)').matches;
        
        if (navStyles.display !== 'none' && isFixed && (!desktopOnly || isDesktop)) {
          navHeight = nav.offsetHeight;
        }
      }

      const headerHeight = header ? header.offsetHeight : 0;
      const bxHeight = bxCreative ? bxCreative.offsetHeight : 0;
      const announcementHeight = announcement && getComputedStyle(announcement).display !== 'none' 
        ? announcement.offsetHeight 
        : 0;

      return headerHeight + bxHeight + announcementHeight + navHeight + extraOffset;
    }

    /**
    * Get the top position of the footer
    * @returns {number} Footer top position relative to document
    */
    function getFooterTop() {
      const footer = document.querySelector('#shopify-section-footer, .footer, .site-footer, footer');
      if (!footer) return Infinity;
      
      const rect = footer.getBoundingClientRect();
      return rect.top + (window.pageYOffset || document.documentElement.scrollTop);
    }

    /**
    * Get current scroll position
    * @returns {number} Current scroll position
    */
    function getScrollTop() {
      return window.pageYOffset || document.documentElement.scrollTop;
    }

    // ========================================
    // STICKY ELEMENT MANAGER
    // ========================================

    /**
    * Create a sticky element controller
    * @param {Object} config - Configuration object
    * @returns {Object} Controller with methods to manage sticky behavior
    */
    function createStickyElement(config) {
      const {
        wrapperSelector,
        barSelector,
        endSentinelSelector,
        placeholderSelector,
        headerOffset = 88,
        createEndSentinel = true,
        mobileOffset = 80,
        onMeasure = null,
        onApply = null
      } = config;

      const wrapper = document.getElementById(wrapperSelector) || document.querySelector(wrapperSelector);
      const bar = document.getElementById(barSelector) || document.querySelector(barSelector);
      const placeholder = document.getElementById(placeholderSelector) || document.querySelector(placeholderSelector);
      
      if (!wrapper || !bar) {
        console.warn('StickyElement: Required elements not found');
        return null;
      }

      let endSentinel = document.getElementById(endSentinelSelector) || document.querySelector(endSentinelSelector);
      
      // Create end sentinel if needed
      if (createEndSentinel && !endSentinel) {
        endSentinel = document.createElement('div');
        endSentinel.id = endSentinelSelector;
        endSentinel.style.height = '1px';
        
        const container = document.getElementById('ProductGridContainer') || wrapper.parentElement;
        container.parentNode.insertBefore(endSentinel, container.nextSibling);
      }

      const state = {
        startY: 0,
        endY: 0,
        offset: 0,
        left: 0,
        width: 0,
        stopY: 0
      };

      function measure() {
        // Reset styles for measurement
        bar.style.position = 'static';
        bar.style.left = '';
        bar.style.width = '';
        bar.style.top = '';
        bar.style.transform = '';
        bar.classList.remove('is-fixed', 'is-docked');

        // Set placeholder height if exists
        if (placeholder) {
          const buttonEl = document.querySelector('.collection-filters__button');
          if (buttonEl) {
            placeholder.style.height = buttonEl.offsetHeight + 'px';
          }
        }

        // Calculate offset
        state.offset = getHeaderOffset({ extraOffset: headerOffset });

        // Calculate positions
        const scrollTop = getScrollTop();
        const wrapperRect = wrapper.getBoundingClientRect();
        state.startY = wrapperRect.top + scrollTop;

        // Add mobile offset if needed
        if (window.innerWidth < 769) {
          state.startY += mobileOffset;
        }

        if (endSentinel) {
          state.endY = endSentinel.getBoundingClientRect().top + scrollTop;
        }

        state.stopY = Math.min(state.endY || Infinity, getFooterTop()) - 1;

        // Measure bar dimensions
        const barRect = bar.getBoundingClientRect();
        state.left = barRect.left + window.pageXOffset;
        state.width = barRect.width;

        // Store in dataset for later use
        bar.dataset.fixedLeft = state.left;
        bar.dataset.fixedWidth = state.width;

        if (onMeasure) onMeasure(state);
      }

      function apply() {
        const scrollY = getScrollTop();
        const barHeight = bar.offsetHeight;

        // Not scrolled past start point
        if (scrollY + state.offset <= state.startY) {
          if (bar.classList.contains('is-fixed') || bar.classList.contains('is-docked')) {
            bar.style.position = 'static';
            bar.style.left = '';
            bar.style.width = '';
            bar.style.top = '';
            bar.style.transform = '';
            bar.classList.remove('is-fixed', 'is-docked');
          }
          return;
        }

        // Reached end point - dock
        if (scrollY + state.offset + barHeight >= state.stopY) {
          const wrapperTop = wrapper.getBoundingClientRect().top + getScrollTop();
          bar.style.position = 'absolute';
          bar.style.zIndex = '5';
          bar.style.top = ((state.stopY - barHeight) - wrapperTop) + 'px';
          bar.style.left = '0';
          bar.style.width = '100%';
          bar.style.transform = '';
          bar.classList.remove('is-fixed');
          bar.classList.add('is-docked');
          return;
        }

        // Fixed in viewport
        const fixedWidth = parseFloat(bar.dataset.fixedWidth) || bar.getBoundingClientRect().width;
        const fixedLeft = parseFloat(bar.dataset.fixedLeft) || (bar.getBoundingClientRect().left + window.pageXOffset);

        bar.style.position = 'fixed';
        bar.style.zIndex = '9';
        bar.style.top = state.offset + 'px';
        bar.style.left = fixedLeft + 'px';
        bar.style.width = fixedWidth + 'px';
        bar.classList.add('is-fixed');
        bar.classList.remove('is-docked');

        // Mobile adjustments
        if (window.innerWidth < 769) {
          bar.style.top = (parseFloat(state.offset) - 88) + 'px';
          bar.style.background = 'var(--color-background, #fff)';
          bar.style.width = '100%';
        }

        if (onApply) onApply(state);
      }

      function recalculate() {
        measure();
        apply();
      }

      function handleScroll() {
        const newOffset = getHeaderOffset({ extraOffset: headerOffset });
        if (Math.abs(newOffset - state.offset) > 2) {
          measure();
        }
        apply();
      }

      // Initialize
      function init() {
        window.addEventListener('load', recalculate, { passive: true });
        window.addEventListener('resize', recalculate, { passive: true });
        window.addEventListener('orientationchange', recalculate, { passive: true });
        window.addEventListener('scroll', handleScroll, { passive: true });
        
        recalculate();
      }

      function destroy() {
        window.removeEventListener('load', recalculate);
        window.removeEventListener('resize', recalculate);
        window.removeEventListener('orientationchange', recalculate);
        window.removeEventListener('scroll', handleScroll);
      }

      return {
        init,
        destroy,
        measure,
        apply,
        recalculate,
        getState: () => ({ ...state })
      };
    }

    // ========================================
    // MOBILE DRAWER MANAGER
    // ========================================

    /**
    * Create a mobile drawer controller with sticky button
    * @param {Object} config - Configuration object
    * @returns {Object} Controller with methods to manage drawer
    */
    function createMobileDrawer(config) {
      const {
        sectionSelector,
        buttonSelector,
        drawerSelector,
        maxWidth = 989,
        zIndices = { header: 200, drawer: 190, button: 120, section: 110 }
      } = config;

      const mediaQuery = window.matchMedia(`(max-width: ${maxWidth}px)`);
      const section = document.querySelector(sectionSelector);
      
      if (!section) {
        console.warn('MobileDrawer: Section not found');
        return null;
      }

      const button = section.querySelector(buttonSelector);
      const drawer = section.querySelector(drawerSelector);

      if (!button || !drawer) {
        console.warn('MobileDrawer: Button or drawer not found');
        return null;
      }

      // Create placeholders
      const sectionPlaceholder = document.createElement('div');
      const buttonPlaceholder = document.createElement('div');
      sectionPlaceholder.style.height = '0px';
      buttonPlaceholder.style.height = '0px';
      section.insertAdjacentElement('afterend', sectionPlaceholder);
      button.insertAdjacentElement('afterend', buttonPlaceholder);

      const state = {
        sectionStartY: 0,
        buttonStartY: 0,
        headerOffset: 0
      };

      function measure() {
        // Reset styles
        [section, button].forEach(el => {
          el.style.position = '';
          el.style.top = '';
          el.style.left = '';
          el.style.right = '';
          el.style.width = '';
          el.style.zIndex = '';
        });

        sectionPlaceholder.style.height = section.offsetHeight + 'px';
        buttonPlaceholder.style.height = button.offsetHeight + 'px';

        state.headerOffset = getHeaderOffset();
        const scrollTop = getScrollTop();
        state.sectionStartY = section.getBoundingClientRect().top + scrollTop;
        state.buttonStartY = button.getBoundingClientRect().top + scrollTop;
      }

      function makeSticky(element, startY, zIndex) {
        const scrollTop = getScrollTop();
        
        if (scrollTop + state.headerOffset > startY) {
          element.style.position = 'fixed';
          element.style.top = state.headerOffset + 'px';
          element.style.left = '0';
          element.style.right = '0';
          element.style.width = '100%';
          element.style.zIndex = zIndex;
          element.style.background = 'var(--color-background, #fff)';
        } else {
          element.style.position = '';
          element.style.top = '';
          element.style.left = '';
          element.style.right = '';
          element.style.width = '';
          element.style.zIndex = '';
          element.style.background = '';
        }
      }

      function styleDrawer() {
        if (!mediaQuery.matches) return;

        const isOpen = drawer.hasAttribute('open') || drawer.classList.contains('is-open');
        const offset = getHeaderOffset();

        if (isOpen) {
          drawer.style.position = 'fixed';
          drawer.style.top = offset + 'px';
          drawer.style.left = '0';
          drawer.style.right = '0';
          drawer.style.height = `calc(100vh - ${offset}px)`;
          drawer.style.maxHeight = drawer.style.height;
          drawer.style.overflow = 'auto';
          drawer.style.webkitOverflowScrolling = 'touch';
          drawer.style.zIndex = zIndices.drawer;
          button.style.zIndex = zIndices.button;
        } else {
          drawer.style.position = 'fixed';
          drawer.style.top = offset + 'px';
          drawer.style.left = '0';
          drawer.style.right = '0';
          drawer.style.height = '0';
          drawer.style.maxHeight = '0';
          drawer.style.overflow = 'hidden';
          drawer.style.width = '0';
          drawer.style.opacity = '0';
          drawer.style.visibility = 'hidden';
          drawer.style.pointerEvents = 'none';
          drawer.style.zIndex = zIndices.drawer;
        }
      }

      function tick() {
        if (!mediaQuery.matches) {
          [section, button].forEach(el => { el.style = ''; });
          sectionPlaceholder.style.height = '0px';
          buttonPlaceholder.style.height = '0px';
          return;
        }

        makeSticky(section, state.sectionStartY, zIndices.section);
        makeSticky(button, state.buttonStartY, zIndices.button);
        styleDrawer();
      }

      function init() {
        window.addEventListener('load', () => { measure(); tick(); });
        window.addEventListener('resize', () => { measure(); tick(); });
        window.addEventListener('scroll', tick, { passive: true });
        
        const observer = new MutationObserver(styleDrawer);
        observer.observe(drawer, { attributes: true });

        measure();
        tick();

        return () => observer.disconnect();
      }

      return { init, measure, tick, getState: () => ({ ...state }) };
    }

    // ========================================
    // STICKY TITLE CAROUSEL
    // ========================================

    /**
    * Create sticky title carousel controllers
    * @param {Object} config - Configuration object
    * @returns {Array} Array of controllers
    */
    function createStickyTitles(config = {}) {
      const {
        selector = '.shopify-section.title-carousel.with-spacing',
        zIndex = 9,
        buffer = 1
      } = config;

      const elements = Array.from(document.querySelectorAll(selector));
      if (!elements.length) return [];

      const controllers = elements.map(element => {
        const placeholder = document.createElement('div');
        placeholder.style.height = '0px';
        element.insertAdjacentElement('afterend', placeholder);

        const state = {
          element,
          placeholder,
          startY: 0,
          stopY: 0,
          headerOffset: 0
        };

        function measure() {
          element.style.position = '';
          element.style.top = '';
          element.style.left = '';
          element.style.right = '';
          element.style.width = '';
          element.style.zIndex = '';
          element.style.background = '';

          state.headerOffset = getHeaderOffset();
          const scrollTop = getScrollTop();
          const rect = element.getBoundingClientRect();
          state.startY = rect.top + scrollTop;
          state.stopY = getFooterTop() - buffer;
        }

        function apply() {
          const scrollY = getScrollTop();
          const height = element.offsetHeight;
          const offset = state.headerOffset;

          // Not scrolled past start
          if (scrollY + offset <= state.startY) {
            if (element.style.position === 'fixed' || element.style.position === 'absolute') {
              element.style.position = '';
              element.style.top = '';
              element.style.left = '';
              element.style.right = '';
              element.style.width = '';
              element.style.zIndex = '';
              element.style.background = '';
            }
            return;
          }

          // Reached stop point
          if (scrollY + offset + height >= state.stopY) {
            const parentTop = element.parentElement.getBoundingClientRect().top + getScrollTop();
            element.style.position = 'absolute';
            element.style.top = ((state.stopY - height) - parentTop) + 'px';
            element.style.left = '0';
            element.style.right = '0';
            element.style.width = '100%';
            element.style.zIndex = zIndex;
            element.style.background = 'var(--color-background, #fff)';
            return;
          }

          // Fixed in viewport
          element.style.position = 'fixed';
          element.style.top = offset + '60px';
          element.style.left = '0';
          element.style.right = '0';
          element.style.width = '100%';
          element.style.zIndex = zIndex;
          element.style.background = 'var(--color-background, #fff)';
        }

        return { measure, apply, getState: () => ({ ...state }) };
      });

      function recalculateAll() {
        controllers.forEach(c => c.measure());
        controllers.forEach(c => c.apply());
      }

      function handleScroll() {
        const oldOffset = controllers[0]?.getState().headerOffset || 0;
        const newOffset = getHeaderOffset();
        if (Math.abs(newOffset - oldOffset) > 2) {
          controllers.forEach(c => c.measure());
        }
        controllers.forEach(c => c.apply());
      }

      function init() {
        window.addEventListener('load', recalculateAll, { passive: true });
        window.addEventListener('resize', recalculateAll, { passive: true });
        window.addEventListener('orientationchange', recalculateAll, { passive: true });
        window.addEventListener('scroll', handleScroll, { passive: true });
        recalculateAll();
      }

      return { controllers, init };
    }

    // ========================================
    // UTILITY FUNCTIONS
    // ========================================

    /**
    * Clear all filters (utility function)
    * @param {Event} event - Event object
    */
    window.clearAll = function(event) {
      if (event) event.preventDefault();
      const filters = document.querySelector('collection-filters');
      if (filters && typeof filters.clearAllFilters === 'function') {
        filters.clearAllFilters();
      }
    };

    // ========================================
    // AUTO-INITIALIZE ALL COMPONENTS
    // ========================================

    const activeControllers = [];

    function initAll() {
      // Clean up existing controllers
      destroyAll();

      // Initialize sticky filter bars (data-sticky-bar)
      document.querySelectorAll('[data-sticky-bar]').forEach(bar => {
        const sectionId = bar.dataset.stickyBar;
        const wrapper = document.querySelector(`[data-sticky-wrapper="${sectionId}"]`);
        const placeholder = document.querySelector(`[data-sticky-placeholder="${sectionId}"]`);
        
        if (wrapper) {
          const controller = createStickyElement({
            wrapperSelector: `[data-sticky-wrapper="${sectionId}"]`,
            barSelector: `[data-sticky-bar="${sectionId}"]`,
            endSentinelSelector: `sticky-end-sentinel-${sectionId}`,
            placeholderSelector: placeholder ? `[data-sticky-placeholder="${sectionId}"]` : null,
            headerOffset: parseInt(bar.dataset.headerOffset || '88'),
            mobileOffset: parseInt(bar.dataset.mobileOffset || '80')
          });
          if (controller) {
            controller.init();
            activeControllers.push(controller);
          }
        }
      });

      // Initialize mobile drawers (data-mobile-drawer)
      document.querySelectorAll('[data-mobile-drawer]').forEach(section => {
        const drawerId = section.dataset.mobileDrawer;
        const buttonSelector = section.dataset.buttonSelector || '.collection-filters__button.hide-desktop';
        const drawerSelector = section.dataset.drawerSelector || 'collection-filters';
        
        const controller = createMobileDrawer({
          sectionSelector: `[data-mobile-drawer="${drawerId}"]`,
          buttonSelector,
          drawerSelector,
          maxWidth: parseInt(section.dataset.maxWidth || '989')
        });
        if (controller) {
          controller.init();
          activeControllers.push({ destroy: controller.init });
        }
      });

      // Initialize sticky titles (data-sticky-title or default selector)
      const titleSelector = document.querySelector('[data-sticky-title]') 
        ? '[data-sticky-title]' 
        : '.shopify-section.title-carousel.with-spacing';
      
      const titleElements = document.querySelectorAll(titleSelector);
      if (titleElements.length > 0) {
        const controller = createStickyTitles({
          selector: titleSelector,
          zIndex: 9
        });
        if (controller) {
          controller.init();
          activeControllers.push(controller);
        }
      }
    }

    function destroyAll() {
      activeControllers.forEach(controller => {
        if (controller && typeof controller.destroy === 'function') {
          controller.destroy();
        }
      });
      activeControllers.length = 0;
    }

    function refresh() {
      initAll();
    }

    // ========================================
    // PUBLIC API
    // ========================================

    return function(action) {
      if (action === 'destroy') {
        destroyAll();
      } else if (action === 'refresh' || !action) {
        refresh();
      }
      
      // Return utility methods
      return {
        getHeaderOffset,
        getFooterTop,
        getScrollTop,
        createStickyElement,
        createMobileDrawer,
        createStickyTitles,
        destroy: destroyAll,
        refresh
      };
    };
  })();

  // Auto-initialize on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.StickyUtils());
  } else {
    window.StickyUtils();
  }
</script>
{% schema %}
{
  "name": "Collection sticky filters",
  "tag": "section",
  "class": "collection-grid-section with-spacing",
  "settings": [
    { "type": "range", "id": "products_per_page", "min": 8, "max": 24, "step": 4, "default": 16, "label": "Products per page" },
    { "type": "select", "id": "image_ratio", "options": [
      { "value": "adapt", "label": "Adapt" },
      { "value": "portrait", "label": "Portrait" },
      { "value": "square", "label": "Square" } ],
      "default": "adapt", "label": "Image ratio" },
    {
      "type": "header",
      "content": "Fiter colors"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text color",
      "default": "#546B82"
    },
    {
      "type": "color",
      "id": "bg_color",
      "label": "Background color",
      "default": "#ffffff"
    },
    { "type": "checkbox", "id": "show_secondary_image", "default": false, "label": "Show secondary image" },
    { "type": "checkbox", "id": "add_image_padding", "default": false, "label": "Add image padding" },
    { "type": "checkbox", "id": "show_image_outline", "default": true, "label": "Show image outline" },
    { "type": "checkbox", "id": "show_vendor", "default": false, "label": "Show vendor" },
    { "type": "checkbox", "id": "show_rating", "default": false, "label": "Show rating" },
    { "type": "checkbox", "id": "enable_filtering", "default": true, "label": "Enable filtering" },
    { "type": "checkbox", "id": "enable_sorting", "default": true, "label": "Enable sorting" },
    { "type": "checkbox", "id": "collapse_on_larger_devices", "default": false, "label": "Collapse on larger devices" }
  ],
  "blocks": [
    {
      "type": "category",
      "name": "Category",
      "settings": [
        {
          "type": "text",
          "id": "title",
          "label": "Title"
        },
          {
          "type": "url",
          "id": "link",
          "label": "Link"
        }
      ]
    }
  ]
}
{% endschema %}